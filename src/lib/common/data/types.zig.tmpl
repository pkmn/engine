//! Code generated by `tools/generate` - manual edits will be overwritten.

const std = @import("std");

const gen1 = @import("../../gen1/data.zig");

const assert = std.debug.assert;
const Effectiveness = gen1.Effectiveness;

const S = Effectiveness.Super;
const N = Effectiveness.Neutral;
const R = Effectiveness.Resisted;
const I = Effectiveness.Immune;

/// Representation of a Generation {{{ roman }}} type in Pokémon.
pub const Type = enum({{{ Type.type }}}) {
    {{{ Type.values }}},

    const CHART: [{{{ Type.num }}}][{{{ Type.num }}}]Effectiveness = .{
        {{{ Type.chart }}}
    };

    {{{ Type.precedence }}}{{{ Type.extra }}}

    comptime {
        assert(@bitSizeOf(Type) == {{{ Type.bitSize }}});
        assert(@sizeOf(@TypeOf(CHART)) == {{{ Type.chartSize }}});
        assert(@sizeOf(@TypeOf(PRECEDENCE)) == {{{ Type.precedenceSize }}});{{{ Type.extraSizes }}}
    }

    /// The number of types in this generation.
    pub const size = {{{ Type.num }}};

    /// Whether or not this type is considered to be special as opposed to physical.
    pub fn special(self: Type) bool {
        return @intFromEnum(self) >= @intFromEnum(Type.Fire);
    }

    /// The `Effectiveness` of type `t2` vs. type `t1`.
    pub fn effectiveness(t1: Type, t2: Type) Effectiveness {
        return CHART[@intFromEnum(t1)][@intFromEnum(t2)];
    }

    {{{ Type.precedenceFn }}}{{{ Type.extraFns }}}
};

/// Representation of a Pokémon's typing.
pub const Types = {{{ Types.qualifier }}} struct {
    /// A Pokémon's primary type.
    type1: Type = .Normal,
    /// A Pokémon's secondary type (may be identical to its primary type).
    type2: Type = .Normal,

    comptime {
        assert(@sizeOf(Types) == {{{ Types.size }}});
    }

    /// Whether this typing is immune to type `t`.
    pub fn immune(self: Types, t: Type) bool {
        return t.effectiveness(self.type1) == I or t.effectiveness(self.type2) == I;
    }

    /// Whether this typing includes type `t`.
    pub fn includes(self: Types, t: Type) bool {
        return self.type1 == t or self.type2 == t;
    }{{{ Types.extraFns }}}
};
